// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BUFFERS_BINANCE_FB_H_
#define FLATBUFFERS_GENERATED_BUFFERS_BINANCE_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

namespace Binance {
namespace fb {

struct PriceLevel;
struct PriceLevelBuilder;
struct PriceLevelT;

struct DepthUpdate;
struct DepthUpdateBuilder;
struct DepthUpdateT;

struct Trade;
struct TradeBuilder;
struct TradeT;

struct AggTrade;
struct AggTradeBuilder;
struct AggTradeT;

struct BookTicker;
struct BookTickerBuilder;
struct BookTickerT;

struct Kline;
struct KlineBuilder;
struct KlineT;

struct orderReport;
struct orderReportBuilder;
struct orderReportT;

struct Envelope;
struct EnvelopeBuilder;
struct EnvelopeT;

enum MessageType : int8_t {
  MessageType_NONE = 0,
  MessageType_DepthUpdate = 1,
  MessageType_Trade = 2,
  MessageType_AggTrade = 3,
  MessageType_BookTicker = 4,
  MessageType_Kline = 5,
  MessageType_orderReport = 6,
  MessageType_MIN = MessageType_NONE,
  MessageType_MAX = MessageType_orderReport
};

inline const MessageType (&EnumValuesMessageType())[7] {
  static const MessageType values[] = {
    MessageType_NONE,
    MessageType_DepthUpdate,
    MessageType_Trade,
    MessageType_AggTrade,
    MessageType_BookTicker,
    MessageType_Kline,
    MessageType_orderReport
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[8] = {
    "NONE",
    "DepthUpdate",
    "Trade",
    "AggTrade",
    "BookTicker",
    "Kline",
    "orderReport",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType_NONE, MessageType_orderReport)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum MessagePayload : uint8_t {
  MessagePayload_NONE = 0,
  MessagePayload_DepthUpdate = 1,
  MessagePayload_Trade = 2,
  MessagePayload_AggTrade = 3,
  MessagePayload_BookTicker = 4,
  MessagePayload_Kline = 5,
  MessagePayload_orderReport = 6,
  MessagePayload_MIN = MessagePayload_NONE,
  MessagePayload_MAX = MessagePayload_orderReport
};

inline const MessagePayload (&EnumValuesMessagePayload())[7] {
  static const MessagePayload values[] = {
    MessagePayload_NONE,
    MessagePayload_DepthUpdate,
    MessagePayload_Trade,
    MessagePayload_AggTrade,
    MessagePayload_BookTicker,
    MessagePayload_Kline,
    MessagePayload_orderReport
  };
  return values;
}

inline const char * const *EnumNamesMessagePayload() {
  static const char * const names[8] = {
    "NONE",
    "DepthUpdate",
    "Trade",
    "AggTrade",
    "BookTicker",
    "Kline",
    "orderReport",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessagePayload(MessagePayload e) {
  if (::flatbuffers::IsOutRange(e, MessagePayload_NONE, MessagePayload_orderReport)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessagePayload()[index];
}

template<typename T> struct MessagePayloadTraits {
  static const MessagePayload enum_value = MessagePayload_NONE;
};

template<> struct MessagePayloadTraits<Binance::fb::DepthUpdate> {
  static const MessagePayload enum_value = MessagePayload_DepthUpdate;
};

template<> struct MessagePayloadTraits<Binance::fb::Trade> {
  static const MessagePayload enum_value = MessagePayload_Trade;
};

template<> struct MessagePayloadTraits<Binance::fb::AggTrade> {
  static const MessagePayload enum_value = MessagePayload_AggTrade;
};

template<> struct MessagePayloadTraits<Binance::fb::BookTicker> {
  static const MessagePayload enum_value = MessagePayload_BookTicker;
};

template<> struct MessagePayloadTraits<Binance::fb::Kline> {
  static const MessagePayload enum_value = MessagePayload_Kline;
};

template<> struct MessagePayloadTraits<Binance::fb::orderReport> {
  static const MessagePayload enum_value = MessagePayload_orderReport;
};

template<typename T> struct MessagePayloadUnionTraits {
  static const MessagePayload enum_value = MessagePayload_NONE;
};

template<> struct MessagePayloadUnionTraits<Binance::fb::DepthUpdateT> {
  static const MessagePayload enum_value = MessagePayload_DepthUpdate;
};

template<> struct MessagePayloadUnionTraits<Binance::fb::TradeT> {
  static const MessagePayload enum_value = MessagePayload_Trade;
};

template<> struct MessagePayloadUnionTraits<Binance::fb::AggTradeT> {
  static const MessagePayload enum_value = MessagePayload_AggTrade;
};

template<> struct MessagePayloadUnionTraits<Binance::fb::BookTickerT> {
  static const MessagePayload enum_value = MessagePayload_BookTicker;
};

template<> struct MessagePayloadUnionTraits<Binance::fb::KlineT> {
  static const MessagePayload enum_value = MessagePayload_Kline;
};

template<> struct MessagePayloadUnionTraits<Binance::fb::orderReportT> {
  static const MessagePayload enum_value = MessagePayload_orderReport;
};

struct MessagePayloadUnion {
  MessagePayload type;
  void *value;

  MessagePayloadUnion() : type(MessagePayload_NONE), value(nullptr) {}
  MessagePayloadUnion(MessagePayloadUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessagePayload_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessagePayloadUnion(const MessagePayloadUnion &);
  MessagePayloadUnion &operator=(const MessagePayloadUnion &u)
    { MessagePayloadUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessagePayloadUnion &operator=(MessagePayloadUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessagePayloadUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = MessagePayloadUnionTraits<RT>::enum_value;
    if (type != MessagePayload_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, MessagePayload type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Binance::fb::DepthUpdateT *AsDepthUpdate() {
    return type == MessagePayload_DepthUpdate ?
      reinterpret_cast<Binance::fb::DepthUpdateT *>(value) : nullptr;
  }
  const Binance::fb::DepthUpdateT *AsDepthUpdate() const {
    return type == MessagePayload_DepthUpdate ?
      reinterpret_cast<const Binance::fb::DepthUpdateT *>(value) : nullptr;
  }
  Binance::fb::TradeT *AsTrade() {
    return type == MessagePayload_Trade ?
      reinterpret_cast<Binance::fb::TradeT *>(value) : nullptr;
  }
  const Binance::fb::TradeT *AsTrade() const {
    return type == MessagePayload_Trade ?
      reinterpret_cast<const Binance::fb::TradeT *>(value) : nullptr;
  }
  Binance::fb::AggTradeT *AsAggTrade() {
    return type == MessagePayload_AggTrade ?
      reinterpret_cast<Binance::fb::AggTradeT *>(value) : nullptr;
  }
  const Binance::fb::AggTradeT *AsAggTrade() const {
    return type == MessagePayload_AggTrade ?
      reinterpret_cast<const Binance::fb::AggTradeT *>(value) : nullptr;
  }
  Binance::fb::BookTickerT *AsBookTicker() {
    return type == MessagePayload_BookTicker ?
      reinterpret_cast<Binance::fb::BookTickerT *>(value) : nullptr;
  }
  const Binance::fb::BookTickerT *AsBookTicker() const {
    return type == MessagePayload_BookTicker ?
      reinterpret_cast<const Binance::fb::BookTickerT *>(value) : nullptr;
  }
  Binance::fb::KlineT *AsKline() {
    return type == MessagePayload_Kline ?
      reinterpret_cast<Binance::fb::KlineT *>(value) : nullptr;
  }
  const Binance::fb::KlineT *AsKline() const {
    return type == MessagePayload_Kline ?
      reinterpret_cast<const Binance::fb::KlineT *>(value) : nullptr;
  }
  Binance::fb::orderReportT *AsorderReport() {
    return type == MessagePayload_orderReport ?
      reinterpret_cast<Binance::fb::orderReportT *>(value) : nullptr;
  }
  const Binance::fb::orderReportT *AsorderReport() const {
    return type == MessagePayload_orderReport ?
      reinterpret_cast<const Binance::fb::orderReportT *>(value) : nullptr;
  }
};

bool VerifyMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, MessagePayload type);
bool VerifyMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct PriceLevelT : public ::flatbuffers::NativeTable {
  typedef PriceLevel TableType;
  double price = 0.0;
  double quantity = 0.0;
};

struct PriceLevel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PriceLevelT NativeTableType;
  typedef PriceLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRICE = 4,
    VT_QUANTITY = 6
  };
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  bool mutate_price(double _price = 0.0) {
    return SetField<double>(VT_PRICE, _price, 0.0);
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, 0.0);
  }
  bool mutate_quantity(double _quantity = 0.0) {
    return SetField<double>(VT_QUANTITY, _quantity, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           verifier.EndTable();
  }
  PriceLevelT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriceLevelT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PriceLevel> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PriceLevelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriceLevelBuilder {
  typedef PriceLevel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_price(double price) {
    fbb_.AddElement<double>(PriceLevel::VT_PRICE, price, 0.0);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(PriceLevel::VT_QUANTITY, quantity, 0.0);
  }
  explicit PriceLevelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PriceLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PriceLevel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PriceLevel> CreatePriceLevel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double price = 0.0,
    double quantity = 0.0) {
  PriceLevelBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  return builder_.Finish();
}

::flatbuffers::Offset<PriceLevel> CreatePriceLevel(::flatbuffers::FlatBufferBuilder &_fbb, const PriceLevelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthUpdateT : public ::flatbuffers::NativeTable {
  typedef DepthUpdate TableType;
  std::string header{};
  uint64_t event_time = 0;
  uint64_t timestamp = 0;
  uint64_t last_update_id = 0;
  std::string symbol{};
  std::vector<std::unique_ptr<Binance::fb::PriceLevelT>> bids{};
  std::vector<std::unique_ptr<Binance::fb::PriceLevelT>> asks{};
  DepthUpdateT() = default;
  DepthUpdateT(const DepthUpdateT &o);
  DepthUpdateT(DepthUpdateT&&) FLATBUFFERS_NOEXCEPT = default;
  DepthUpdateT &operator=(DepthUpdateT o) FLATBUFFERS_NOEXCEPT;
};

struct DepthUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepthUpdateT NativeTableType;
  typedef DepthUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_EVENT_TIME = 6,
    VT_TIMESTAMP = 8,
    VT_LAST_UPDATE_ID = 10,
    VT_SYMBOL = 12,
    VT_BIDS = 14,
    VT_ASKS = 16
  };
  const ::flatbuffers::String *header() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HEADER);
  }
  ::flatbuffers::String *mutable_header() {
    return GetPointer<::flatbuffers::String *>(VT_HEADER);
  }
  uint64_t event_time() const {
    return GetField<uint64_t>(VT_EVENT_TIME, 0);
  }
  bool mutate_event_time(uint64_t _event_time = 0) {
    return SetField<uint64_t>(VT_EVENT_TIME, _event_time, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  uint64_t last_update_id() const {
    return GetField<uint64_t>(VT_LAST_UPDATE_ID, 0);
  }
  bool mutate_last_update_id(uint64_t _last_update_id = 0) {
    return SetField<uint64_t>(VT_LAST_UPDATE_ID, _last_update_id, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *bids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *>(VT_BIDS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *mutable_bids() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *>(VT_BIDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *asks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *>(VT_ASKS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *mutable_asks() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *>(VT_ASKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyString(header()) &&
           VerifyField<uint64_t>(verifier, VT_EVENT_TIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint64_t>(verifier, VT_LAST_UPDATE_ID, 8) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           verifier.VerifyVectorOfTables(bids()) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           verifier.VerifyVectorOfTables(asks()) &&
           verifier.EndTable();
  }
  DepthUpdateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthUpdateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DepthUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthUpdateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthUpdateBuilder {
  typedef DepthUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<::flatbuffers::String> header) {
    fbb_.AddOffset(DepthUpdate::VT_HEADER, header);
  }
  void add_event_time(uint64_t event_time) {
    fbb_.AddElement<uint64_t>(DepthUpdate::VT_EVENT_TIME, event_time, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(DepthUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  void add_last_update_id(uint64_t last_update_id) {
    fbb_.AddElement<uint64_t>(DepthUpdate::VT_LAST_UPDATE_ID, last_update_id, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(DepthUpdate::VT_SYMBOL, symbol);
  }
  void add_bids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>>> bids) {
    fbb_.AddOffset(DepthUpdate::VT_BIDS, bids);
  }
  void add_asks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>>> asks) {
    fbb_.AddOffset(DepthUpdate::VT_ASKS, asks);
  }
  explicit DepthUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepthUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepthUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepthUpdate> CreateDepthUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> header = 0,
    uint64_t event_time = 0,
    uint64_t timestamp = 0,
    uint64_t last_update_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>>> bids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Binance::fb::PriceLevel>>> asks = 0) {
  DepthUpdateBuilder builder_(_fbb);
  builder_.add_last_update_id(last_update_id);
  builder_.add_timestamp(timestamp);
  builder_.add_event_time(event_time);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_symbol(symbol);
  builder_.add_header(header);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DepthUpdate> CreateDepthUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *header = nullptr,
    uint64_t event_time = 0,
    uint64_t timestamp = 0,
    uint64_t last_update_id = 0,
    const char *symbol = nullptr,
    const std::vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *bids = nullptr,
    const std::vector<::flatbuffers::Offset<Binance::fb::PriceLevel>> *asks = nullptr) {
  auto header__ = header ? _fbb.CreateString(header) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto bids__ = bids ? _fbb.CreateVector<::flatbuffers::Offset<Binance::fb::PriceLevel>>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVector<::flatbuffers::Offset<Binance::fb::PriceLevel>>(*asks) : 0;
  return Binance::fb::CreateDepthUpdate(
      _fbb,
      header__,
      event_time,
      timestamp,
      last_update_id,
      symbol__,
      bids__,
      asks__);
}

::flatbuffers::Offset<DepthUpdate> CreateDepthUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const DepthUpdateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TradeT : public ::flatbuffers::NativeTable {
  typedef Trade TableType;
  std::string event_type{};
  uint64_t event_time = 0;
  std::string symbol{};
  uint64_t trade_id = 0;
  double price = 0.0;
  double quantity = 0.0;
  uint64_t trade_time = 0;
  bool is_buyer_maker = false;
};

struct Trade FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TradeT NativeTableType;
  typedef TradeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT_TIME = 6,
    VT_SYMBOL = 8,
    VT_TRADE_ID = 10,
    VT_PRICE = 12,
    VT_QUANTITY = 14,
    VT_TRADE_TIME = 16,
    VT_IS_BUYER_MAKER = 18
  };
  const ::flatbuffers::String *event_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVENT_TYPE);
  }
  ::flatbuffers::String *mutable_event_type() {
    return GetPointer<::flatbuffers::String *>(VT_EVENT_TYPE);
  }
  uint64_t event_time() const {
    return GetField<uint64_t>(VT_EVENT_TIME, 0);
  }
  bool mutate_event_time(uint64_t _event_time = 0) {
    return SetField<uint64_t>(VT_EVENT_TIME, _event_time, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  uint64_t trade_id() const {
    return GetField<uint64_t>(VT_TRADE_ID, 0);
  }
  bool mutate_trade_id(uint64_t _trade_id = 0) {
    return SetField<uint64_t>(VT_TRADE_ID, _trade_id, 0);
  }
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  bool mutate_price(double _price = 0.0) {
    return SetField<double>(VT_PRICE, _price, 0.0);
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, 0.0);
  }
  bool mutate_quantity(double _quantity = 0.0) {
    return SetField<double>(VT_QUANTITY, _quantity, 0.0);
  }
  uint64_t trade_time() const {
    return GetField<uint64_t>(VT_TRADE_TIME, 0);
  }
  bool mutate_trade_time(uint64_t _trade_time = 0) {
    return SetField<uint64_t>(VT_TRADE_TIME, _trade_time, 0);
  }
  bool is_buyer_maker() const {
    return GetField<uint8_t>(VT_IS_BUYER_MAKER, 0) != 0;
  }
  bool mutate_is_buyer_maker(bool _is_buyer_maker = 0) {
    return SetField<uint8_t>(VT_IS_BUYER_MAKER, static_cast<uint8_t>(_is_buyer_maker), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENT_TYPE) &&
           verifier.VerifyString(event_type()) &&
           VerifyField<uint64_t>(verifier, VT_EVENT_TIME, 8) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint64_t>(verifier, VT_TRADE_ID, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<uint64_t>(verifier, VT_TRADE_TIME, 8) &&
           VerifyField<uint8_t>(verifier, VT_IS_BUYER_MAKER, 1) &&
           verifier.EndTable();
  }
  TradeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TradeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Trade> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TradeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TradeBuilder {
  typedef Trade Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(::flatbuffers::Offset<::flatbuffers::String> event_type) {
    fbb_.AddOffset(Trade::VT_EVENT_TYPE, event_type);
  }
  void add_event_time(uint64_t event_time) {
    fbb_.AddElement<uint64_t>(Trade::VT_EVENT_TIME, event_time, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(Trade::VT_SYMBOL, symbol);
  }
  void add_trade_id(uint64_t trade_id) {
    fbb_.AddElement<uint64_t>(Trade::VT_TRADE_ID, trade_id, 0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(Trade::VT_PRICE, price, 0.0);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(Trade::VT_QUANTITY, quantity, 0.0);
  }
  void add_trade_time(uint64_t trade_time) {
    fbb_.AddElement<uint64_t>(Trade::VT_TRADE_TIME, trade_time, 0);
  }
  void add_is_buyer_maker(bool is_buyer_maker) {
    fbb_.AddElement<uint8_t>(Trade::VT_IS_BUYER_MAKER, static_cast<uint8_t>(is_buyer_maker), 0);
  }
  explicit TradeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Trade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Trade>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Trade> CreateTrade(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> event_type = 0,
    uint64_t event_time = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    uint64_t trade_id = 0,
    double price = 0.0,
    double quantity = 0.0,
    uint64_t trade_time = 0,
    bool is_buyer_maker = false) {
  TradeBuilder builder_(_fbb);
  builder_.add_trade_time(trade_time);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_trade_id(trade_id);
  builder_.add_event_time(event_time);
  builder_.add_symbol(symbol);
  builder_.add_event_type(event_type);
  builder_.add_is_buyer_maker(is_buyer_maker);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Trade> CreateTradeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *event_type = nullptr,
    uint64_t event_time = 0,
    const char *symbol = nullptr,
    uint64_t trade_id = 0,
    double price = 0.0,
    double quantity = 0.0,
    uint64_t trade_time = 0,
    bool is_buyer_maker = false) {
  auto event_type__ = event_type ? _fbb.CreateString(event_type) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return Binance::fb::CreateTrade(
      _fbb,
      event_type__,
      event_time,
      symbol__,
      trade_id,
      price,
      quantity,
      trade_time,
      is_buyer_maker);
}

::flatbuffers::Offset<Trade> CreateTrade(::flatbuffers::FlatBufferBuilder &_fbb, const TradeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AggTradeT : public ::flatbuffers::NativeTable {
  typedef AggTrade TableType;
  std::string event_type{};
  uint64_t event_time = 0;
  std::string symbol{};
  uint64_t agg_trade_id = 0;
  double price = 0.0;
  double quantity = 0.0;
  uint64_t first_trade_id = 0;
  uint64_t last_trade_id = 0;
  uint64_t trade_time = 0;
  bool is_buyer_maker = false;
};

struct AggTrade FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AggTradeT NativeTableType;
  typedef AggTradeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT_TIME = 6,
    VT_SYMBOL = 8,
    VT_AGG_TRADE_ID = 10,
    VT_PRICE = 12,
    VT_QUANTITY = 14,
    VT_FIRST_TRADE_ID = 16,
    VT_LAST_TRADE_ID = 18,
    VT_TRADE_TIME = 20,
    VT_IS_BUYER_MAKER = 22
  };
  const ::flatbuffers::String *event_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVENT_TYPE);
  }
  ::flatbuffers::String *mutable_event_type() {
    return GetPointer<::flatbuffers::String *>(VT_EVENT_TYPE);
  }
  uint64_t event_time() const {
    return GetField<uint64_t>(VT_EVENT_TIME, 0);
  }
  bool mutate_event_time(uint64_t _event_time = 0) {
    return SetField<uint64_t>(VT_EVENT_TIME, _event_time, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  uint64_t agg_trade_id() const {
    return GetField<uint64_t>(VT_AGG_TRADE_ID, 0);
  }
  bool mutate_agg_trade_id(uint64_t _agg_trade_id = 0) {
    return SetField<uint64_t>(VT_AGG_TRADE_ID, _agg_trade_id, 0);
  }
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  bool mutate_price(double _price = 0.0) {
    return SetField<double>(VT_PRICE, _price, 0.0);
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, 0.0);
  }
  bool mutate_quantity(double _quantity = 0.0) {
    return SetField<double>(VT_QUANTITY, _quantity, 0.0);
  }
  uint64_t first_trade_id() const {
    return GetField<uint64_t>(VT_FIRST_TRADE_ID, 0);
  }
  bool mutate_first_trade_id(uint64_t _first_trade_id = 0) {
    return SetField<uint64_t>(VT_FIRST_TRADE_ID, _first_trade_id, 0);
  }
  uint64_t last_trade_id() const {
    return GetField<uint64_t>(VT_LAST_TRADE_ID, 0);
  }
  bool mutate_last_trade_id(uint64_t _last_trade_id = 0) {
    return SetField<uint64_t>(VT_LAST_TRADE_ID, _last_trade_id, 0);
  }
  uint64_t trade_time() const {
    return GetField<uint64_t>(VT_TRADE_TIME, 0);
  }
  bool mutate_trade_time(uint64_t _trade_time = 0) {
    return SetField<uint64_t>(VT_TRADE_TIME, _trade_time, 0);
  }
  bool is_buyer_maker() const {
    return GetField<uint8_t>(VT_IS_BUYER_MAKER, 0) != 0;
  }
  bool mutate_is_buyer_maker(bool _is_buyer_maker = 0) {
    return SetField<uint8_t>(VT_IS_BUYER_MAKER, static_cast<uint8_t>(_is_buyer_maker), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENT_TYPE) &&
           verifier.VerifyString(event_type()) &&
           VerifyField<uint64_t>(verifier, VT_EVENT_TIME, 8) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint64_t>(verifier, VT_AGG_TRADE_ID, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<uint64_t>(verifier, VT_FIRST_TRADE_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_LAST_TRADE_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_TRADE_TIME, 8) &&
           VerifyField<uint8_t>(verifier, VT_IS_BUYER_MAKER, 1) &&
           verifier.EndTable();
  }
  AggTradeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AggTradeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AggTrade> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AggTradeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AggTradeBuilder {
  typedef AggTrade Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(::flatbuffers::Offset<::flatbuffers::String> event_type) {
    fbb_.AddOffset(AggTrade::VT_EVENT_TYPE, event_type);
  }
  void add_event_time(uint64_t event_time) {
    fbb_.AddElement<uint64_t>(AggTrade::VT_EVENT_TIME, event_time, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(AggTrade::VT_SYMBOL, symbol);
  }
  void add_agg_trade_id(uint64_t agg_trade_id) {
    fbb_.AddElement<uint64_t>(AggTrade::VT_AGG_TRADE_ID, agg_trade_id, 0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(AggTrade::VT_PRICE, price, 0.0);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(AggTrade::VT_QUANTITY, quantity, 0.0);
  }
  void add_first_trade_id(uint64_t first_trade_id) {
    fbb_.AddElement<uint64_t>(AggTrade::VT_FIRST_TRADE_ID, first_trade_id, 0);
  }
  void add_last_trade_id(uint64_t last_trade_id) {
    fbb_.AddElement<uint64_t>(AggTrade::VT_LAST_TRADE_ID, last_trade_id, 0);
  }
  void add_trade_time(uint64_t trade_time) {
    fbb_.AddElement<uint64_t>(AggTrade::VT_TRADE_TIME, trade_time, 0);
  }
  void add_is_buyer_maker(bool is_buyer_maker) {
    fbb_.AddElement<uint8_t>(AggTrade::VT_IS_BUYER_MAKER, static_cast<uint8_t>(is_buyer_maker), 0);
  }
  explicit AggTradeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AggTrade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AggTrade>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AggTrade> CreateAggTrade(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> event_type = 0,
    uint64_t event_time = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    uint64_t agg_trade_id = 0,
    double price = 0.0,
    double quantity = 0.0,
    uint64_t first_trade_id = 0,
    uint64_t last_trade_id = 0,
    uint64_t trade_time = 0,
    bool is_buyer_maker = false) {
  AggTradeBuilder builder_(_fbb);
  builder_.add_trade_time(trade_time);
  builder_.add_last_trade_id(last_trade_id);
  builder_.add_first_trade_id(first_trade_id);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_agg_trade_id(agg_trade_id);
  builder_.add_event_time(event_time);
  builder_.add_symbol(symbol);
  builder_.add_event_type(event_type);
  builder_.add_is_buyer_maker(is_buyer_maker);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AggTrade> CreateAggTradeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *event_type = nullptr,
    uint64_t event_time = 0,
    const char *symbol = nullptr,
    uint64_t agg_trade_id = 0,
    double price = 0.0,
    double quantity = 0.0,
    uint64_t first_trade_id = 0,
    uint64_t last_trade_id = 0,
    uint64_t trade_time = 0,
    bool is_buyer_maker = false) {
  auto event_type__ = event_type ? _fbb.CreateString(event_type) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return Binance::fb::CreateAggTrade(
      _fbb,
      event_type__,
      event_time,
      symbol__,
      agg_trade_id,
      price,
      quantity,
      first_trade_id,
      last_trade_id,
      trade_time,
      is_buyer_maker);
}

::flatbuffers::Offset<AggTrade> CreateAggTrade(::flatbuffers::FlatBufferBuilder &_fbb, const AggTradeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BookTickerT : public ::flatbuffers::NativeTable {
  typedef BookTicker TableType;
  uint64_t update_id = 0;
  std::string symbol{};
  double best_bid_price = 0.0;
  double best_bid_qty = 0.0;
  double best_ask_price = 0.0;
  double best_ask_qty = 0.0;
};

struct BookTicker FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BookTickerT NativeTableType;
  typedef BookTickerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_ID = 4,
    VT_SYMBOL = 6,
    VT_BEST_BID_PRICE = 8,
    VT_BEST_BID_QTY = 10,
    VT_BEST_ASK_PRICE = 12,
    VT_BEST_ASK_QTY = 14
  };
  uint64_t update_id() const {
    return GetField<uint64_t>(VT_UPDATE_ID, 0);
  }
  bool mutate_update_id(uint64_t _update_id = 0) {
    return SetField<uint64_t>(VT_UPDATE_ID, _update_id, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  double best_bid_price() const {
    return GetField<double>(VT_BEST_BID_PRICE, 0.0);
  }
  bool mutate_best_bid_price(double _best_bid_price = 0.0) {
    return SetField<double>(VT_BEST_BID_PRICE, _best_bid_price, 0.0);
  }
  double best_bid_qty() const {
    return GetField<double>(VT_BEST_BID_QTY, 0.0);
  }
  bool mutate_best_bid_qty(double _best_bid_qty = 0.0) {
    return SetField<double>(VT_BEST_BID_QTY, _best_bid_qty, 0.0);
  }
  double best_ask_price() const {
    return GetField<double>(VT_BEST_ASK_PRICE, 0.0);
  }
  bool mutate_best_ask_price(double _best_ask_price = 0.0) {
    return SetField<double>(VT_BEST_ASK_PRICE, _best_ask_price, 0.0);
  }
  double best_ask_qty() const {
    return GetField<double>(VT_BEST_ASK_QTY, 0.0);
  }
  bool mutate_best_ask_qty(double _best_ask_qty = 0.0) {
    return SetField<double>(VT_BEST_ASK_QTY, _best_ask_qty, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPDATE_ID, 8) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<double>(verifier, VT_BEST_BID_PRICE, 8) &&
           VerifyField<double>(verifier, VT_BEST_BID_QTY, 8) &&
           VerifyField<double>(verifier, VT_BEST_ASK_PRICE, 8) &&
           VerifyField<double>(verifier, VT_BEST_ASK_QTY, 8) &&
           verifier.EndTable();
  }
  BookTickerT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BookTickerT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BookTicker> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BookTickerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BookTickerBuilder {
  typedef BookTicker Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_id(uint64_t update_id) {
    fbb_.AddElement<uint64_t>(BookTicker::VT_UPDATE_ID, update_id, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(BookTicker::VT_SYMBOL, symbol);
  }
  void add_best_bid_price(double best_bid_price) {
    fbb_.AddElement<double>(BookTicker::VT_BEST_BID_PRICE, best_bid_price, 0.0);
  }
  void add_best_bid_qty(double best_bid_qty) {
    fbb_.AddElement<double>(BookTicker::VT_BEST_BID_QTY, best_bid_qty, 0.0);
  }
  void add_best_ask_price(double best_ask_price) {
    fbb_.AddElement<double>(BookTicker::VT_BEST_ASK_PRICE, best_ask_price, 0.0);
  }
  void add_best_ask_qty(double best_ask_qty) {
    fbb_.AddElement<double>(BookTicker::VT_BEST_ASK_QTY, best_ask_qty, 0.0);
  }
  explicit BookTickerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BookTicker> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BookTicker>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BookTicker> CreateBookTicker(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t update_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    double best_bid_price = 0.0,
    double best_bid_qty = 0.0,
    double best_ask_price = 0.0,
    double best_ask_qty = 0.0) {
  BookTickerBuilder builder_(_fbb);
  builder_.add_best_ask_qty(best_ask_qty);
  builder_.add_best_ask_price(best_ask_price);
  builder_.add_best_bid_qty(best_bid_qty);
  builder_.add_best_bid_price(best_bid_price);
  builder_.add_update_id(update_id);
  builder_.add_symbol(symbol);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BookTicker> CreateBookTickerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t update_id = 0,
    const char *symbol = nullptr,
    double best_bid_price = 0.0,
    double best_bid_qty = 0.0,
    double best_ask_price = 0.0,
    double best_ask_qty = 0.0) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return Binance::fb::CreateBookTicker(
      _fbb,
      update_id,
      symbol__,
      best_bid_price,
      best_bid_qty,
      best_ask_price,
      best_ask_qty);
}

::flatbuffers::Offset<BookTicker> CreateBookTicker(::flatbuffers::FlatBufferBuilder &_fbb, const BookTickerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KlineT : public ::flatbuffers::NativeTable {
  typedef Kline TableType;
  uint64_t start_time = 0;
  uint64_t close_time = 0;
  std::string symbol{};
  std::string interval{};
  uint64_t first_trade_id = 0;
  uint64_t last_trade_id = 0;
  double open_price = 0.0;
  double close_price = 0.0;
  double high_price = 0.0;
  double low_price = 0.0;
  double base_asset_volume = 0.0;
  uint64_t number_of_trades = 0;
  bool is_closed = false;
  double quote_asset_volume = 0.0;
  double taker_buy_base_asset_volume = 0.0;
  double taker_buy_quote_asset_volume = 0.0;
};

struct Kline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KlineT NativeTableType;
  typedef KlineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_TIME = 4,
    VT_CLOSE_TIME = 6,
    VT_SYMBOL = 8,
    VT_INTERVAL = 10,
    VT_FIRST_TRADE_ID = 12,
    VT_LAST_TRADE_ID = 14,
    VT_OPEN_PRICE = 16,
    VT_CLOSE_PRICE = 18,
    VT_HIGH_PRICE = 20,
    VT_LOW_PRICE = 22,
    VT_BASE_ASSET_VOLUME = 24,
    VT_NUMBER_OF_TRADES = 26,
    VT_IS_CLOSED = 28,
    VT_QUOTE_ASSET_VOLUME = 30,
    VT_TAKER_BUY_BASE_ASSET_VOLUME = 32,
    VT_TAKER_BUY_QUOTE_ASSET_VOLUME = 34
  };
  uint64_t start_time() const {
    return GetField<uint64_t>(VT_START_TIME, 0);
  }
  bool mutate_start_time(uint64_t _start_time = 0) {
    return SetField<uint64_t>(VT_START_TIME, _start_time, 0);
  }
  uint64_t close_time() const {
    return GetField<uint64_t>(VT_CLOSE_TIME, 0);
  }
  bool mutate_close_time(uint64_t _close_time = 0) {
    return SetField<uint64_t>(VT_CLOSE_TIME, _close_time, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  const ::flatbuffers::String *interval() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERVAL);
  }
  ::flatbuffers::String *mutable_interval() {
    return GetPointer<::flatbuffers::String *>(VT_INTERVAL);
  }
  uint64_t first_trade_id() const {
    return GetField<uint64_t>(VT_FIRST_TRADE_ID, 0);
  }
  bool mutate_first_trade_id(uint64_t _first_trade_id = 0) {
    return SetField<uint64_t>(VT_FIRST_TRADE_ID, _first_trade_id, 0);
  }
  uint64_t last_trade_id() const {
    return GetField<uint64_t>(VT_LAST_TRADE_ID, 0);
  }
  bool mutate_last_trade_id(uint64_t _last_trade_id = 0) {
    return SetField<uint64_t>(VT_LAST_TRADE_ID, _last_trade_id, 0);
  }
  double open_price() const {
    return GetField<double>(VT_OPEN_PRICE, 0.0);
  }
  bool mutate_open_price(double _open_price = 0.0) {
    return SetField<double>(VT_OPEN_PRICE, _open_price, 0.0);
  }
  double close_price() const {
    return GetField<double>(VT_CLOSE_PRICE, 0.0);
  }
  bool mutate_close_price(double _close_price = 0.0) {
    return SetField<double>(VT_CLOSE_PRICE, _close_price, 0.0);
  }
  double high_price() const {
    return GetField<double>(VT_HIGH_PRICE, 0.0);
  }
  bool mutate_high_price(double _high_price = 0.0) {
    return SetField<double>(VT_HIGH_PRICE, _high_price, 0.0);
  }
  double low_price() const {
    return GetField<double>(VT_LOW_PRICE, 0.0);
  }
  bool mutate_low_price(double _low_price = 0.0) {
    return SetField<double>(VT_LOW_PRICE, _low_price, 0.0);
  }
  double base_asset_volume() const {
    return GetField<double>(VT_BASE_ASSET_VOLUME, 0.0);
  }
  bool mutate_base_asset_volume(double _base_asset_volume = 0.0) {
    return SetField<double>(VT_BASE_ASSET_VOLUME, _base_asset_volume, 0.0);
  }
  uint64_t number_of_trades() const {
    return GetField<uint64_t>(VT_NUMBER_OF_TRADES, 0);
  }
  bool mutate_number_of_trades(uint64_t _number_of_trades = 0) {
    return SetField<uint64_t>(VT_NUMBER_OF_TRADES, _number_of_trades, 0);
  }
  bool is_closed() const {
    return GetField<uint8_t>(VT_IS_CLOSED, 0) != 0;
  }
  bool mutate_is_closed(bool _is_closed = 0) {
    return SetField<uint8_t>(VT_IS_CLOSED, static_cast<uint8_t>(_is_closed), 0);
  }
  double quote_asset_volume() const {
    return GetField<double>(VT_QUOTE_ASSET_VOLUME, 0.0);
  }
  bool mutate_quote_asset_volume(double _quote_asset_volume = 0.0) {
    return SetField<double>(VT_QUOTE_ASSET_VOLUME, _quote_asset_volume, 0.0);
  }
  double taker_buy_base_asset_volume() const {
    return GetField<double>(VT_TAKER_BUY_BASE_ASSET_VOLUME, 0.0);
  }
  bool mutate_taker_buy_base_asset_volume(double _taker_buy_base_asset_volume = 0.0) {
    return SetField<double>(VT_TAKER_BUY_BASE_ASSET_VOLUME, _taker_buy_base_asset_volume, 0.0);
  }
  double taker_buy_quote_asset_volume() const {
    return GetField<double>(VT_TAKER_BUY_QUOTE_ASSET_VOLUME, 0.0);
  }
  bool mutate_taker_buy_quote_asset_volume(double _taker_buy_quote_asset_volume = 0.0) {
    return SetField<double>(VT_TAKER_BUY_QUOTE_ASSET_VOLUME, _taker_buy_quote_asset_volume, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_START_TIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_CLOSE_TIME, 8) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_INTERVAL) &&
           verifier.VerifyString(interval()) &&
           VerifyField<uint64_t>(verifier, VT_FIRST_TRADE_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_LAST_TRADE_ID, 8) &&
           VerifyField<double>(verifier, VT_OPEN_PRICE, 8) &&
           VerifyField<double>(verifier, VT_CLOSE_PRICE, 8) &&
           VerifyField<double>(verifier, VT_HIGH_PRICE, 8) &&
           VerifyField<double>(verifier, VT_LOW_PRICE, 8) &&
           VerifyField<double>(verifier, VT_BASE_ASSET_VOLUME, 8) &&
           VerifyField<uint64_t>(verifier, VT_NUMBER_OF_TRADES, 8) &&
           VerifyField<uint8_t>(verifier, VT_IS_CLOSED, 1) &&
           VerifyField<double>(verifier, VT_QUOTE_ASSET_VOLUME, 8) &&
           VerifyField<double>(verifier, VT_TAKER_BUY_BASE_ASSET_VOLUME, 8) &&
           VerifyField<double>(verifier, VT_TAKER_BUY_QUOTE_ASSET_VOLUME, 8) &&
           verifier.EndTable();
  }
  KlineT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KlineT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Kline> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KlineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KlineBuilder {
  typedef Kline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_time(uint64_t start_time) {
    fbb_.AddElement<uint64_t>(Kline::VT_START_TIME, start_time, 0);
  }
  void add_close_time(uint64_t close_time) {
    fbb_.AddElement<uint64_t>(Kline::VT_CLOSE_TIME, close_time, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(Kline::VT_SYMBOL, symbol);
  }
  void add_interval(::flatbuffers::Offset<::flatbuffers::String> interval) {
    fbb_.AddOffset(Kline::VT_INTERVAL, interval);
  }
  void add_first_trade_id(uint64_t first_trade_id) {
    fbb_.AddElement<uint64_t>(Kline::VT_FIRST_TRADE_ID, first_trade_id, 0);
  }
  void add_last_trade_id(uint64_t last_trade_id) {
    fbb_.AddElement<uint64_t>(Kline::VT_LAST_TRADE_ID, last_trade_id, 0);
  }
  void add_open_price(double open_price) {
    fbb_.AddElement<double>(Kline::VT_OPEN_PRICE, open_price, 0.0);
  }
  void add_close_price(double close_price) {
    fbb_.AddElement<double>(Kline::VT_CLOSE_PRICE, close_price, 0.0);
  }
  void add_high_price(double high_price) {
    fbb_.AddElement<double>(Kline::VT_HIGH_PRICE, high_price, 0.0);
  }
  void add_low_price(double low_price) {
    fbb_.AddElement<double>(Kline::VT_LOW_PRICE, low_price, 0.0);
  }
  void add_base_asset_volume(double base_asset_volume) {
    fbb_.AddElement<double>(Kline::VT_BASE_ASSET_VOLUME, base_asset_volume, 0.0);
  }
  void add_number_of_trades(uint64_t number_of_trades) {
    fbb_.AddElement<uint64_t>(Kline::VT_NUMBER_OF_TRADES, number_of_trades, 0);
  }
  void add_is_closed(bool is_closed) {
    fbb_.AddElement<uint8_t>(Kline::VT_IS_CLOSED, static_cast<uint8_t>(is_closed), 0);
  }
  void add_quote_asset_volume(double quote_asset_volume) {
    fbb_.AddElement<double>(Kline::VT_QUOTE_ASSET_VOLUME, quote_asset_volume, 0.0);
  }
  void add_taker_buy_base_asset_volume(double taker_buy_base_asset_volume) {
    fbb_.AddElement<double>(Kline::VT_TAKER_BUY_BASE_ASSET_VOLUME, taker_buy_base_asset_volume, 0.0);
  }
  void add_taker_buy_quote_asset_volume(double taker_buy_quote_asset_volume) {
    fbb_.AddElement<double>(Kline::VT_TAKER_BUY_QUOTE_ASSET_VOLUME, taker_buy_quote_asset_volume, 0.0);
  }
  explicit KlineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Kline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Kline>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Kline> CreateKline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start_time = 0,
    uint64_t close_time = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    ::flatbuffers::Offset<::flatbuffers::String> interval = 0,
    uint64_t first_trade_id = 0,
    uint64_t last_trade_id = 0,
    double open_price = 0.0,
    double close_price = 0.0,
    double high_price = 0.0,
    double low_price = 0.0,
    double base_asset_volume = 0.0,
    uint64_t number_of_trades = 0,
    bool is_closed = false,
    double quote_asset_volume = 0.0,
    double taker_buy_base_asset_volume = 0.0,
    double taker_buy_quote_asset_volume = 0.0) {
  KlineBuilder builder_(_fbb);
  builder_.add_taker_buy_quote_asset_volume(taker_buy_quote_asset_volume);
  builder_.add_taker_buy_base_asset_volume(taker_buy_base_asset_volume);
  builder_.add_quote_asset_volume(quote_asset_volume);
  builder_.add_number_of_trades(number_of_trades);
  builder_.add_base_asset_volume(base_asset_volume);
  builder_.add_low_price(low_price);
  builder_.add_high_price(high_price);
  builder_.add_close_price(close_price);
  builder_.add_open_price(open_price);
  builder_.add_last_trade_id(last_trade_id);
  builder_.add_first_trade_id(first_trade_id);
  builder_.add_close_time(close_time);
  builder_.add_start_time(start_time);
  builder_.add_interval(interval);
  builder_.add_symbol(symbol);
  builder_.add_is_closed(is_closed);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Kline> CreateKlineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start_time = 0,
    uint64_t close_time = 0,
    const char *symbol = nullptr,
    const char *interval = nullptr,
    uint64_t first_trade_id = 0,
    uint64_t last_trade_id = 0,
    double open_price = 0.0,
    double close_price = 0.0,
    double high_price = 0.0,
    double low_price = 0.0,
    double base_asset_volume = 0.0,
    uint64_t number_of_trades = 0,
    bool is_closed = false,
    double quote_asset_volume = 0.0,
    double taker_buy_base_asset_volume = 0.0,
    double taker_buy_quote_asset_volume = 0.0) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto interval__ = interval ? _fbb.CreateString(interval) : 0;
  return Binance::fb::CreateKline(
      _fbb,
      start_time,
      close_time,
      symbol__,
      interval__,
      first_trade_id,
      last_trade_id,
      open_price,
      close_price,
      high_price,
      low_price,
      base_asset_volume,
      number_of_trades,
      is_closed,
      quote_asset_volume,
      taker_buy_base_asset_volume,
      taker_buy_quote_asset_volume);
}

::flatbuffers::Offset<Kline> CreateKline(::flatbuffers::FlatBufferBuilder &_fbb, const KlineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct orderReportT : public ::flatbuffers::NativeTable {
  typedef orderReport TableType;
  uint64_t id = 0;
  std::string client_order_id{};
  std::string symbol{};
  std::string side{};
  std::string status{};
  double executed_qty = 0.0;
};

struct orderReport FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef orderReportT NativeTableType;
  typedef orderReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLIENT_ORDER_ID = 6,
    VT_SYMBOL = 8,
    VT_SIDE = 10,
    VT_STATUS = 12,
    VT_EXECUTED_QTY = 14
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  const ::flatbuffers::String *client_order_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENT_ORDER_ID);
  }
  ::flatbuffers::String *mutable_client_order_id() {
    return GetPointer<::flatbuffers::String *>(VT_CLIENT_ORDER_ID);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  const ::flatbuffers::String *side() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIDE);
  }
  ::flatbuffers::String *mutable_side() {
    return GetPointer<::flatbuffers::String *>(VT_SIDE);
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  ::flatbuffers::String *mutable_status() {
    return GetPointer<::flatbuffers::String *>(VT_STATUS);
  }
  double executed_qty() const {
    return GetField<double>(VT_EXECUTED_QTY, 0.0);
  }
  bool mutate_executed_qty(double _executed_qty = 0.0) {
    return SetField<double>(VT_EXECUTED_QTY, _executed_qty, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_CLIENT_ORDER_ID) &&
           verifier.VerifyString(client_order_id()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_SIDE) &&
           verifier.VerifyString(side()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<double>(verifier, VT_EXECUTED_QTY, 8) &&
           verifier.EndTable();
  }
  orderReportT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(orderReportT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<orderReport> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const orderReportT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct orderReportBuilder {
  typedef orderReport Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(orderReport::VT_ID, id, 0);
  }
  void add_client_order_id(::flatbuffers::Offset<::flatbuffers::String> client_order_id) {
    fbb_.AddOffset(orderReport::VT_CLIENT_ORDER_ID, client_order_id);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(orderReport::VT_SYMBOL, symbol);
  }
  void add_side(::flatbuffers::Offset<::flatbuffers::String> side) {
    fbb_.AddOffset(orderReport::VT_SIDE, side);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(orderReport::VT_STATUS, status);
  }
  void add_executed_qty(double executed_qty) {
    fbb_.AddElement<double>(orderReport::VT_EXECUTED_QTY, executed_qty, 0.0);
  }
  explicit orderReportBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<orderReport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<orderReport>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<orderReport> CreateorderReport(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> client_order_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    ::flatbuffers::Offset<::flatbuffers::String> side = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    double executed_qty = 0.0) {
  orderReportBuilder builder_(_fbb);
  builder_.add_executed_qty(executed_qty);
  builder_.add_id(id);
  builder_.add_status(status);
  builder_.add_side(side);
  builder_.add_symbol(symbol);
  builder_.add_client_order_id(client_order_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<orderReport> CreateorderReportDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *client_order_id = nullptr,
    const char *symbol = nullptr,
    const char *side = nullptr,
    const char *status = nullptr,
    double executed_qty = 0.0) {
  auto client_order_id__ = client_order_id ? _fbb.CreateString(client_order_id) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto side__ = side ? _fbb.CreateString(side) : 0;
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return Binance::fb::CreateorderReport(
      _fbb,
      id,
      client_order_id__,
      symbol__,
      side__,
      status__,
      executed_qty);
}

::flatbuffers::Offset<orderReport> CreateorderReport(::flatbuffers::FlatBufferBuilder &_fbb, const orderReportT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnvelopeT : public ::flatbuffers::NativeTable {
  typedef Envelope TableType;
  Binance::fb::MessageType type = Binance::fb::MessageType_NONE;
  Binance::fb::MessagePayloadUnion payload{};
};

struct Envelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnvelopeT NativeTableType;
  typedef EnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  Binance::fb::MessageType type() const {
    return static_cast<Binance::fb::MessageType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(Binance::fb::MessageType _type = static_cast<Binance::fb::MessageType>(0)) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  Binance::fb::MessagePayload payload_type() const {
    return static_cast<Binance::fb::MessagePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const Binance::fb::DepthUpdate *payload_as_DepthUpdate() const {
    return payload_type() == Binance::fb::MessagePayload_DepthUpdate ? static_cast<const Binance::fb::DepthUpdate *>(payload()) : nullptr;
  }
  const Binance::fb::Trade *payload_as_Trade() const {
    return payload_type() == Binance::fb::MessagePayload_Trade ? static_cast<const Binance::fb::Trade *>(payload()) : nullptr;
  }
  const Binance::fb::AggTrade *payload_as_AggTrade() const {
    return payload_type() == Binance::fb::MessagePayload_AggTrade ? static_cast<const Binance::fb::AggTrade *>(payload()) : nullptr;
  }
  const Binance::fb::BookTicker *payload_as_BookTicker() const {
    return payload_type() == Binance::fb::MessagePayload_BookTicker ? static_cast<const Binance::fb::BookTicker *>(payload()) : nullptr;
  }
  const Binance::fb::Kline *payload_as_Kline() const {
    return payload_type() == Binance::fb::MessagePayload_Kline ? static_cast<const Binance::fb::Kline *>(payload()) : nullptr;
  }
  const Binance::fb::orderReport *payload_as_orderReport() const {
    return payload_type() == Binance::fb::MessagePayload_orderReport ? static_cast<const Binance::fb::orderReport *>(payload()) : nullptr;
  }
  void *mutable_payload() {
    return GetPointer<void *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyMessagePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
  EnvelopeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnvelopeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Envelope> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Binance::fb::DepthUpdate *Envelope::payload_as<Binance::fb::DepthUpdate>() const {
  return payload_as_DepthUpdate();
}

template<> inline const Binance::fb::Trade *Envelope::payload_as<Binance::fb::Trade>() const {
  return payload_as_Trade();
}

template<> inline const Binance::fb::AggTrade *Envelope::payload_as<Binance::fb::AggTrade>() const {
  return payload_as_AggTrade();
}

template<> inline const Binance::fb::BookTicker *Envelope::payload_as<Binance::fb::BookTicker>() const {
  return payload_as_BookTicker();
}

template<> inline const Binance::fb::Kline *Envelope::payload_as<Binance::fb::Kline>() const {
  return payload_as_Kline();
}

template<> inline const Binance::fb::orderReport *Envelope::payload_as<Binance::fb::orderReport>() const {
  return payload_as_orderReport();
}

struct EnvelopeBuilder {
  typedef Envelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(Binance::fb::MessageType type) {
    fbb_.AddElement<int8_t>(Envelope::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_payload_type(Binance::fb::MessagePayload payload_type) {
    fbb_.AddElement<uint8_t>(Envelope::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Envelope::VT_PAYLOAD, payload);
  }
  explicit EnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Envelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Envelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Envelope> CreateEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Binance::fb::MessageType type = Binance::fb::MessageType_NONE,
    Binance::fb::MessagePayload payload_type = Binance::fb::MessagePayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  EnvelopeBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  builder_.add_type(type);
  return builder_.Finish();
}

::flatbuffers::Offset<Envelope> CreateEnvelope(::flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PriceLevelT *PriceLevel::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PriceLevelT>(new PriceLevelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PriceLevel::UnPackTo(PriceLevelT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = price(); _o->price = _e; }
  { auto _e = quantity(); _o->quantity = _e; }
}

inline ::flatbuffers::Offset<PriceLevel> PriceLevel::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PriceLevelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriceLevel(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PriceLevel> CreatePriceLevel(::flatbuffers::FlatBufferBuilder &_fbb, const PriceLevelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PriceLevelT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _price = _o->price;
  auto _quantity = _o->quantity;
  return Binance::fb::CreatePriceLevel(
      _fbb,
      _price,
      _quantity);
}

inline DepthUpdateT::DepthUpdateT(const DepthUpdateT &o)
      : header(o.header),
        event_time(o.event_time),
        timestamp(o.timestamp),
        last_update_id(o.last_update_id),
        symbol(o.symbol) {
  bids.reserve(o.bids.size());
  for (const auto &bids_ : o.bids) { bids.emplace_back((bids_) ? new Binance::fb::PriceLevelT(*bids_) : nullptr); }
  asks.reserve(o.asks.size());
  for (const auto &asks_ : o.asks) { asks.emplace_back((asks_) ? new Binance::fb::PriceLevelT(*asks_) : nullptr); }
}

inline DepthUpdateT &DepthUpdateT::operator=(DepthUpdateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(header, o.header);
  std::swap(event_time, o.event_time);
  std::swap(timestamp, o.timestamp);
  std::swap(last_update_id, o.last_update_id);
  std::swap(symbol, o.symbol);
  std::swap(bids, o.bids);
  std::swap(asks, o.asks);
  return *this;
}

inline DepthUpdateT *DepthUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DepthUpdateT>(new DepthUpdateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepthUpdate::UnPackTo(DepthUpdateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = header(); if (_e) _o->header = _e->str(); }
  { auto _e = event_time(); _o->event_time = _e; }
  { auto _e = timestamp(); _o->timestamp = _e; }
  { auto _e = last_update_id(); _o->last_update_id = _e; }
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = bids(); if (_e) { _o->bids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->bids[_i]) { _e->Get(_i)->UnPackTo(_o->bids[_i].get(), _resolver); } else { _o->bids[_i] = std::unique_ptr<Binance::fb::PriceLevelT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->bids.resize(0); } }
  { auto _e = asks(); if (_e) { _o->asks.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->asks[_i]) { _e->Get(_i)->UnPackTo(_o->asks[_i].get(), _resolver); } else { _o->asks[_i] = std::unique_ptr<Binance::fb::PriceLevelT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->asks.resize(0); } }
}

inline ::flatbuffers::Offset<DepthUpdate> DepthUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthUpdateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DepthUpdate> CreateDepthUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const DepthUpdateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DepthUpdateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _header = _o->header.empty() ? 0 : _fbb.CreateString(_o->header);
  auto _event_time = _o->event_time;
  auto _timestamp = _o->timestamp;
  auto _last_update_id = _o->last_update_id;
  auto _symbol = _o->symbol.empty() ? 0 : _fbb.CreateString(_o->symbol);
  auto _bids = _o->bids.size() ? _fbb.CreateVector<::flatbuffers::Offset<Binance::fb::PriceLevel>> (_o->bids.size(), [](size_t i, _VectorArgs *__va) { return CreatePriceLevel(*__va->__fbb, __va->__o->bids[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _asks = _o->asks.size() ? _fbb.CreateVector<::flatbuffers::Offset<Binance::fb::PriceLevel>> (_o->asks.size(), [](size_t i, _VectorArgs *__va) { return CreatePriceLevel(*__va->__fbb, __va->__o->asks[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Binance::fb::CreateDepthUpdate(
      _fbb,
      _header,
      _event_time,
      _timestamp,
      _last_update_id,
      _symbol,
      _bids,
      _asks);
}

inline TradeT *Trade::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TradeT>(new TradeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Trade::UnPackTo(TradeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_type(); if (_e) _o->event_type = _e->str(); }
  { auto _e = event_time(); _o->event_time = _e; }
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = trade_id(); _o->trade_id = _e; }
  { auto _e = price(); _o->price = _e; }
  { auto _e = quantity(); _o->quantity = _e; }
  { auto _e = trade_time(); _o->trade_time = _e; }
  { auto _e = is_buyer_maker(); _o->is_buyer_maker = _e; }
}

inline ::flatbuffers::Offset<Trade> Trade::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TradeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTrade(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Trade> CreateTrade(::flatbuffers::FlatBufferBuilder &_fbb, const TradeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TradeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_type = _o->event_type.empty() ? 0 : _fbb.CreateString(_o->event_type);
  auto _event_time = _o->event_time;
  auto _symbol = _o->symbol.empty() ? 0 : _fbb.CreateString(_o->symbol);
  auto _trade_id = _o->trade_id;
  auto _price = _o->price;
  auto _quantity = _o->quantity;
  auto _trade_time = _o->trade_time;
  auto _is_buyer_maker = _o->is_buyer_maker;
  return Binance::fb::CreateTrade(
      _fbb,
      _event_type,
      _event_time,
      _symbol,
      _trade_id,
      _price,
      _quantity,
      _trade_time,
      _is_buyer_maker);
}

inline AggTradeT *AggTrade::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AggTradeT>(new AggTradeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AggTrade::UnPackTo(AggTradeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_type(); if (_e) _o->event_type = _e->str(); }
  { auto _e = event_time(); _o->event_time = _e; }
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = agg_trade_id(); _o->agg_trade_id = _e; }
  { auto _e = price(); _o->price = _e; }
  { auto _e = quantity(); _o->quantity = _e; }
  { auto _e = first_trade_id(); _o->first_trade_id = _e; }
  { auto _e = last_trade_id(); _o->last_trade_id = _e; }
  { auto _e = trade_time(); _o->trade_time = _e; }
  { auto _e = is_buyer_maker(); _o->is_buyer_maker = _e; }
}

inline ::flatbuffers::Offset<AggTrade> AggTrade::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AggTradeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAggTrade(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AggTrade> CreateAggTrade(::flatbuffers::FlatBufferBuilder &_fbb, const AggTradeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AggTradeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_type = _o->event_type.empty() ? 0 : _fbb.CreateString(_o->event_type);
  auto _event_time = _o->event_time;
  auto _symbol = _o->symbol.empty() ? 0 : _fbb.CreateString(_o->symbol);
  auto _agg_trade_id = _o->agg_trade_id;
  auto _price = _o->price;
  auto _quantity = _o->quantity;
  auto _first_trade_id = _o->first_trade_id;
  auto _last_trade_id = _o->last_trade_id;
  auto _trade_time = _o->trade_time;
  auto _is_buyer_maker = _o->is_buyer_maker;
  return Binance::fb::CreateAggTrade(
      _fbb,
      _event_type,
      _event_time,
      _symbol,
      _agg_trade_id,
      _price,
      _quantity,
      _first_trade_id,
      _last_trade_id,
      _trade_time,
      _is_buyer_maker);
}

inline BookTickerT *BookTicker::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BookTickerT>(new BookTickerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BookTicker::UnPackTo(BookTickerT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = update_id(); _o->update_id = _e; }
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = best_bid_price(); _o->best_bid_price = _e; }
  { auto _e = best_bid_qty(); _o->best_bid_qty = _e; }
  { auto _e = best_ask_price(); _o->best_ask_price = _e; }
  { auto _e = best_ask_qty(); _o->best_ask_qty = _e; }
}

inline ::flatbuffers::Offset<BookTicker> BookTicker::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BookTickerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBookTicker(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BookTicker> CreateBookTicker(::flatbuffers::FlatBufferBuilder &_fbb, const BookTickerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BookTickerT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _update_id = _o->update_id;
  auto _symbol = _o->symbol.empty() ? 0 : _fbb.CreateString(_o->symbol);
  auto _best_bid_price = _o->best_bid_price;
  auto _best_bid_qty = _o->best_bid_qty;
  auto _best_ask_price = _o->best_ask_price;
  auto _best_ask_qty = _o->best_ask_qty;
  return Binance::fb::CreateBookTicker(
      _fbb,
      _update_id,
      _symbol,
      _best_bid_price,
      _best_bid_qty,
      _best_ask_price,
      _best_ask_qty);
}

inline KlineT *Kline::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<KlineT>(new KlineT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Kline::UnPackTo(KlineT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_time(); _o->start_time = _e; }
  { auto _e = close_time(); _o->close_time = _e; }
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = interval(); if (_e) _o->interval = _e->str(); }
  { auto _e = first_trade_id(); _o->first_trade_id = _e; }
  { auto _e = last_trade_id(); _o->last_trade_id = _e; }
  { auto _e = open_price(); _o->open_price = _e; }
  { auto _e = close_price(); _o->close_price = _e; }
  { auto _e = high_price(); _o->high_price = _e; }
  { auto _e = low_price(); _o->low_price = _e; }
  { auto _e = base_asset_volume(); _o->base_asset_volume = _e; }
  { auto _e = number_of_trades(); _o->number_of_trades = _e; }
  { auto _e = is_closed(); _o->is_closed = _e; }
  { auto _e = quote_asset_volume(); _o->quote_asset_volume = _e; }
  { auto _e = taker_buy_base_asset_volume(); _o->taker_buy_base_asset_volume = _e; }
  { auto _e = taker_buy_quote_asset_volume(); _o->taker_buy_quote_asset_volume = _e; }
}

inline ::flatbuffers::Offset<Kline> Kline::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KlineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKline(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Kline> CreateKline(::flatbuffers::FlatBufferBuilder &_fbb, const KlineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const KlineT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_time = _o->start_time;
  auto _close_time = _o->close_time;
  auto _symbol = _o->symbol.empty() ? 0 : _fbb.CreateString(_o->symbol);
  auto _interval = _o->interval.empty() ? 0 : _fbb.CreateString(_o->interval);
  auto _first_trade_id = _o->first_trade_id;
  auto _last_trade_id = _o->last_trade_id;
  auto _open_price = _o->open_price;
  auto _close_price = _o->close_price;
  auto _high_price = _o->high_price;
  auto _low_price = _o->low_price;
  auto _base_asset_volume = _o->base_asset_volume;
  auto _number_of_trades = _o->number_of_trades;
  auto _is_closed = _o->is_closed;
  auto _quote_asset_volume = _o->quote_asset_volume;
  auto _taker_buy_base_asset_volume = _o->taker_buy_base_asset_volume;
  auto _taker_buy_quote_asset_volume = _o->taker_buy_quote_asset_volume;
  return Binance::fb::CreateKline(
      _fbb,
      _start_time,
      _close_time,
      _symbol,
      _interval,
      _first_trade_id,
      _last_trade_id,
      _open_price,
      _close_price,
      _high_price,
      _low_price,
      _base_asset_volume,
      _number_of_trades,
      _is_closed,
      _quote_asset_volume,
      _taker_buy_base_asset_volume,
      _taker_buy_quote_asset_volume);
}

inline orderReportT *orderReport::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<orderReportT>(new orderReportT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void orderReport::UnPackTo(orderReportT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = client_order_id(); if (_e) _o->client_order_id = _e->str(); }
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = side(); if (_e) _o->side = _e->str(); }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = executed_qty(); _o->executed_qty = _e; }
}

inline ::flatbuffers::Offset<orderReport> orderReport::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const orderReportT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateorderReport(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<orderReport> CreateorderReport(::flatbuffers::FlatBufferBuilder &_fbb, const orderReportT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const orderReportT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _client_order_id = _o->client_order_id.empty() ? 0 : _fbb.CreateString(_o->client_order_id);
  auto _symbol = _o->symbol.empty() ? 0 : _fbb.CreateString(_o->symbol);
  auto _side = _o->side.empty() ? 0 : _fbb.CreateString(_o->side);
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  auto _executed_qty = _o->executed_qty;
  return Binance::fb::CreateorderReport(
      _fbb,
      _id,
      _client_order_id,
      _symbol,
      _side,
      _status,
      _executed_qty);
}

inline EnvelopeT *Envelope::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EnvelopeT>(new EnvelopeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Envelope::UnPackTo(EnvelopeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = payload_type(); _o->payload.type = _e; }
  { auto _e = payload(); if (_e) _o->payload.value = Binance::fb::MessagePayloadUnion::UnPack(_e, payload_type(), _resolver); }
}

inline ::flatbuffers::Offset<Envelope> Envelope::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnvelope(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Envelope> CreateEnvelope(::flatbuffers::FlatBufferBuilder &_fbb, const EnvelopeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EnvelopeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _payload_type = _o->payload.type;
  auto _payload = _o->payload.Pack(_fbb);
  return Binance::fb::CreateEnvelope(
      _fbb,
      _type,
      _payload_type,
      _payload);
}

inline bool VerifyMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, MessagePayload type) {
  switch (type) {
    case MessagePayload_NONE: {
      return true;
    }
    case MessagePayload_DepthUpdate: {
      auto ptr = reinterpret_cast<const Binance::fb::DepthUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessagePayload_Trade: {
      auto ptr = reinterpret_cast<const Binance::fb::Trade *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessagePayload_AggTrade: {
      auto ptr = reinterpret_cast<const Binance::fb::AggTrade *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessagePayload_BookTicker: {
      auto ptr = reinterpret_cast<const Binance::fb::BookTicker *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessagePayload_Kline: {
      auto ptr = reinterpret_cast<const Binance::fb::Kline *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessagePayload_orderReport: {
      auto ptr = reinterpret_cast<const Binance::fb::orderReport *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessagePayload(
        verifier,  values->Get(i), types->GetEnum<MessagePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessagePayloadUnion::UnPack(const void *obj, MessagePayload type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case MessagePayload_DepthUpdate: {
      auto ptr = reinterpret_cast<const Binance::fb::DepthUpdate *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessagePayload_Trade: {
      auto ptr = reinterpret_cast<const Binance::fb::Trade *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessagePayload_AggTrade: {
      auto ptr = reinterpret_cast<const Binance::fb::AggTrade *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessagePayload_BookTicker: {
      auto ptr = reinterpret_cast<const Binance::fb::BookTicker *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessagePayload_Kline: {
      auto ptr = reinterpret_cast<const Binance::fb::Kline *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessagePayload_orderReport: {
      auto ptr = reinterpret_cast<const Binance::fb::orderReport *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> MessagePayloadUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case MessagePayload_DepthUpdate: {
      auto ptr = reinterpret_cast<const Binance::fb::DepthUpdateT *>(value);
      return CreateDepthUpdate(_fbb, ptr, _rehasher).Union();
    }
    case MessagePayload_Trade: {
      auto ptr = reinterpret_cast<const Binance::fb::TradeT *>(value);
      return CreateTrade(_fbb, ptr, _rehasher).Union();
    }
    case MessagePayload_AggTrade: {
      auto ptr = reinterpret_cast<const Binance::fb::AggTradeT *>(value);
      return CreateAggTrade(_fbb, ptr, _rehasher).Union();
    }
    case MessagePayload_BookTicker: {
      auto ptr = reinterpret_cast<const Binance::fb::BookTickerT *>(value);
      return CreateBookTicker(_fbb, ptr, _rehasher).Union();
    }
    case MessagePayload_Kline: {
      auto ptr = reinterpret_cast<const Binance::fb::KlineT *>(value);
      return CreateKline(_fbb, ptr, _rehasher).Union();
    }
    case MessagePayload_orderReport: {
      auto ptr = reinterpret_cast<const Binance::fb::orderReportT *>(value);
      return CreateorderReport(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessagePayloadUnion::MessagePayloadUnion(const MessagePayloadUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MessagePayload_DepthUpdate: {
      value = new Binance::fb::DepthUpdateT(*reinterpret_cast<Binance::fb::DepthUpdateT *>(u.value));
      break;
    }
    case MessagePayload_Trade: {
      value = new Binance::fb::TradeT(*reinterpret_cast<Binance::fb::TradeT *>(u.value));
      break;
    }
    case MessagePayload_AggTrade: {
      value = new Binance::fb::AggTradeT(*reinterpret_cast<Binance::fb::AggTradeT *>(u.value));
      break;
    }
    case MessagePayload_BookTicker: {
      value = new Binance::fb::BookTickerT(*reinterpret_cast<Binance::fb::BookTickerT *>(u.value));
      break;
    }
    case MessagePayload_Kline: {
      value = new Binance::fb::KlineT(*reinterpret_cast<Binance::fb::KlineT *>(u.value));
      break;
    }
    case MessagePayload_orderReport: {
      value = new Binance::fb::orderReportT(*reinterpret_cast<Binance::fb::orderReportT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessagePayloadUnion::Reset() {
  switch (type) {
    case MessagePayload_DepthUpdate: {
      auto ptr = reinterpret_cast<Binance::fb::DepthUpdateT *>(value);
      delete ptr;
      break;
    }
    case MessagePayload_Trade: {
      auto ptr = reinterpret_cast<Binance::fb::TradeT *>(value);
      delete ptr;
      break;
    }
    case MessagePayload_AggTrade: {
      auto ptr = reinterpret_cast<Binance::fb::AggTradeT *>(value);
      delete ptr;
      break;
    }
    case MessagePayload_BookTicker: {
      auto ptr = reinterpret_cast<Binance::fb::BookTickerT *>(value);
      delete ptr;
      break;
    }
    case MessagePayload_Kline: {
      auto ptr = reinterpret_cast<Binance::fb::KlineT *>(value);
      delete ptr;
      break;
    }
    case MessagePayload_orderReport: {
      auto ptr = reinterpret_cast<Binance::fb::orderReportT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessagePayload_NONE;
}

inline const Binance::fb::Envelope *GetEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<Binance::fb::Envelope>(buf);
}

inline const Binance::fb::Envelope *GetSizePrefixedEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Binance::fb::Envelope>(buf);
}

inline Envelope *GetMutableEnvelope(void *buf) {
  return ::flatbuffers::GetMutableRoot<Envelope>(buf);
}

inline Binance::fb::Envelope *GetMutableSizePrefixedEnvelope(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Binance::fb::Envelope>(buf);
}

inline bool VerifyEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Binance::fb::Envelope>(nullptr);
}

inline bool VerifySizePrefixedEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Binance::fb::Envelope>(nullptr);
}

inline void FinishEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Binance::fb::Envelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Binance::fb::Envelope> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Binance::fb::EnvelopeT> UnPackEnvelope(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Binance::fb::EnvelopeT>(GetEnvelope(buf)->UnPack(res));
}

inline std::unique_ptr<Binance::fb::EnvelopeT> UnPackSizePrefixedEnvelope(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Binance::fb::EnvelopeT>(GetSizePrefixedEnvelope(buf)->UnPack(res));
}

}  // namespace fb
}  // namespace Binance

#endif  // FLATBUFFERS_GENERATED_BUFFERS_BINANCE_FB_H_
